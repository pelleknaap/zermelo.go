package zermelo

import (
	"encoding/json"
	"fmt"
	"github.com/pkg/errors"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// ZermeloData is the struct that holds all the methods and data that is needed by the methods
type ZermeloData struct {
	School string
	Start  string
	End    string

	// the "koppel code", not the api key
	AuthCode string

	// the api key that can be retrieved by using the GetApiKey() function
	Key           string
	Appointments  Appointments
	Announcements Announcements
}

// JSONWrapperAppointments is a wrapper for the appointment struct
// needed to decode the json
type JSONWrapperAppointments struct {
	Response *Appointments
}

// JSONWrapperAnnouncements is a wrapper for the announcements struct
// It's needed to decode the json from the request
type JSONWrapperAnnouncements struct {
	Response *Announcements
}

// JSONApiKeyWrapper  is a wrapper for the api key string
// It's needed to decode the json from the request
type JSONApiKeyWrapper struct {
	AccessToken string `json:"access_token"`
}

// Appointments holds all the data of appointments
type Appointments struct {
	// the status of the api request, should be 200
	Status    int
	TotalRows int
	Data      []Lesson
}

// Lesson holds all the data of a lesson, it's used in the Appointments struct
type Lesson struct {
	ID                  int      `json:"id"`
	AppointmentInstance int      `json:"appointmentInstance"`
	Start               int      `json:"start"`
	End                 int      `json:"end"`
	StartTimeSlot       int      `json:"startTimeSlot"`
	EndTimeSlot         int      `json:"endTimeSlot"`
	Subjects            []string `json:"subjects"`
	Teachers            []string `json:"teachers"`
	Groups              []string `json:"groups"`
	GroupsInDepartments []int    `json:"groupsInDepartment"`
	Locations           []string `json:"locations"`
	LocationsOfBranch   []int    `json:"locationsOfBranch"`
	Type                string   `json:"type"`
	Remark              string   `json:"remark"`
	Valid               bool     `json:"valid"`
	Cancelled           bool     `json:"cancelled"`
	Modified            bool     `json:"modified"`
	Moved               bool     `json:"moved"`
	New                 bool     `json:"new"`
	ChangeDescription   string   `json:"changeDescription"`
}

// Announcements is the slice of the Announcement
// It's needed to store the additional data generated by the api, otherwise it was redundant
type Announcements struct {
	Status    int
	Message   string
	StartRow  int
	EndRow    int
	TotalRows int
	Data      []Announcement
}

// Announcement holds all the data of an announcement
type Announcement struct {
	Id    int
	Start int
	End   int
	Title string
	Text  string
}

// GetAppointments gets all the appointments from the Zermelo api
// used z.Start & z.End to determine the period of the appointments
// Needs z.Key to access the API, will return an error if there isn't one
// Makes a request to the Zermelo api and fills the z.Appointments slice
func (z *ZermeloData) GetAppointments() error {
	if z.Start == "" || z.End == "" || z.Key == "" {
		return errors.New("Not all needed variables are present, check the z.Start, z.End & the z.Key variables")
	}

	// make the url
	var reqUrl strings.Builder
	fmt.Fprintf(&reqUrl, "https://%s.zportal.nl/api/v3/", z.School)
	reqUrl.WriteString("appointments?user=~me")
	reqUrl.WriteString("&start=" + z.Start)
	reqUrl.WriteString("&end=" + z.End)
	reqUrl.WriteString("&access_token=" + z.Key)

	// Get the data
	resp, err := http.Get(reqUrl.String())
	if err != nil {
		return errors.Wrap(err, "Error getting json data")
	}

	// Check if nothing went wrong with the request
	if resp.StatusCode != http.StatusOK {
		return errors.New("Wrong statuscode returned")
	}

	defer resp.Body.Close()

	appointments, err := decodeJsonAppointments(resp.Body)
	if err != nil {
		return err
	}

	z.Appointments = appointments

	// Check if Zermelo's api also returned 200 as a Status
	if z.Appointments.Status != 200 {
		return errors.New("Returned status code isn't 200, it is: " + strconv.Itoa(z.Appointments.Status))
	}

	return nil
}

func decodeJsonAppointments(body io.Reader) (Appointments, error){
	var appoinmentsWrapper JSONWrapperAppointments

	decoder := json.NewDecoder(body)
	err := decoder.Decode(&appoinmentsWrapper)
	if err != nil {
		return Appointments{}, errors.Wrap(err, "Error decoding json")
	}

	return *appoinmentsWrapper.Response, nil
}

// GetAnnouncements gets all announcements from the Zermelo API
// The z.Key variable needs to be present, an error will be returned if it isn't
// fills the z.Announcements slice, returns error if something went wrong
func (z *ZermeloData) GetAnnouncements() error {
	if z.Key == "" {
		return errors.New("Not all needed variables are present, check the z.Start, z.End & the z.Key variables")
	}

	// Create the url for the request
	var reqUrl strings.Builder
	fmt.Fprintf(&reqUrl, "https://%s.zportal.nl/api/v2/", z.School)
	reqUrl.WriteString("announcements?user=~me")
	reqUrl.WriteString("&current=true")
	reqUrl.WriteString("&access_token=" + z.Key)

	// create and execute the request
	resp, err := http.Get(reqUrl.String())
	if err != nil {
		return errors.Wrap(err, "Error getting json data")
	}

	// check if nothing went wrong
	if resp.StatusCode != http.StatusOK {
		return errors.New("Wrong statuscode returned")
	}

	defer resp.Body.Close()

	announcements, err := decodeJsonAnnouncements(resp.Body)
	if err != nil {
		return err
	}

	z.Announcements = announcements

	if z.Announcements.Status != 200 {
		return errors.New("Returned status code isn't 200, it is: " + strconv.Itoa(z.Announcements.Status))
	}

	return nil
}

func decodeJsonAnnouncements(body io.Reader) (Announcements, error){
	var announcementsWrapper JSONWrapperAnnouncements

	decoder := json.NewDecoder(body)
	err := decoder.Decode(&announcementsWrapper)
	if err != nil {
		return Announcements{}, errors.Wrap(err, "Error decoding json")
	}

	return *announcementsWrapper.Response, nil
}

// GetApiKey gets the api key needed to interact with the api from the zermelo api
// The z.Authcode variable needs to be present, otherwise an error will be returned
func (z *ZermeloData) GetApiKey() error {
	if z.AuthCode == "" {
		return errors.New("Please fill-in the auth code before trying to get an apikey")
	}

	resp, err := http.PostForm("https://"+z.School+".zportal.nl/api/v2/oauth/token",
		url.Values{"grant_type": {"authorization_code"}, "code": {z.AuthCode}})

	if err != nil {
		return errors.Wrap(err, "Error getting api key")
	}

	if resp.StatusCode != http.StatusOK {
		return errors.New("Wrong statuscode returned, code: " + strconv.Itoa(resp.StatusCode))
	}

	defer resp.Body.Close()

	var apiKeyWrapper JSONApiKeyWrapper

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&apiKeyWrapper)
	if err != nil {
		return errors.Wrap(err, "Error decoding json")
	}

	z.Key = apiKeyWrapper.AccessToken
	return nil
}
